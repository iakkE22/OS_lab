# lab0.5

## 练习1：使用GDB验证启动流程

# lab1

## 练习1：理解内核启动中的程序入口操作

阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

**答：**

| 指令                | 操作                                      | 目的                                      |
| ------------------- | ----------------------------------------- | ----------------------------------------- |
| la sp, bootstacktop | 将bootstacktop的地址写入栈指针寄存器      | 标识栈顶位置                              |
| tail kern_init      | 将kern_init的地址写入pc寄存器，并修改x[6] | 将程序跳转到kern_init，完成初始地址的跳转 |



## 练习2：完善中断处理

请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。

要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

**答：**见git仓库

## 扩展练习1：描述与理解中断流程

回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

**答：**

1. 异常产生后经过`trap`,`trap_dispatch`两个函数后依据其原因进入`exception_handler`函数中进行处理，并对其原因`tf->cause`进行进一步细分的处理。
2. `a0-a7`在RISC-V中用于传递函数的参数，注意到trap.h中有关`trapframe`的定义，其顺序与压栈的顺序是一致的，因此此处的`mov a0, sp`即将该`trapframe`的地址（指针）传递给`trap`函数，随后使用`tf->cause`也是基于结构体内的顺序化定义方式才能正确访问
3. 注意到trap.h中对于`trapframe`的定义以及`pushregs`的定义，这样的压栈顺序是为了手动创建一个`trapframe`结构体，以便访问其内容来决定`trap`时的处理句柄（函数）以及具体的处理方式
4. 由于trap.h中对`trapframe`结构体的定义，为了完成一次正确的`trap`中断，需要传递一个正确的结构，这就要求压入所有的指针；但如果其中有一部分的寄存器值为0，或许可以不用专门压栈（即`STORE`，但仍需要分配同样大的空间），但是判断的开销不可忽略

## 扩展练习2：理解上下文切换机制

回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

**答：**

1. | 指令                     | 操作                                                     | 目的                                                         |
   | ------------------------ | -------------------------------------------------------- | ------------------------------------------------------------ |
   | `csrw sscratch, sp;`     | 将`sp`写入`sscratch`寄存器中                             | 临时保存`sp`的位置，之后要写入到`s0`（即`fp`）中保存         |
   | `scrrw s0, sscratch, x0` | 将`sscratch`写入`s0`中并将`x0`写入`sscratch`中（即清零） | 转移原来的栈顶位置到`s0`中并清零`sscratch`，以用于确定该中断是来自内核的，在之后的恢复过程完成调用`sret`后也能够恢复原来的`sp`信息 |

   注：`s0`即`fp`寄存器，存储`sp`的目的是为了退出特权模式（即`sret`后）可以恢复到运行前状态

2. 观察`trap`的运行流程，不难发现存入的这些寄存器都是用于提供中断的信息支持的（在新栈顶作为的结构体中）， 并且这些寄存器本来就是临时的特权寄存器，无需恢复

   注意到`sstatus`和`spec`寄存器的值被恢复，这两个寄存器是为了存储进入特权模式前的处理器状态，需要恢复

3. `store`的目的是为了维护`trapframe`的结构，为其中的每个变量提供值（`struct`的嵌套在汇编层面上是直接展开的，而不是存储一个指针，要按顺序直接压入所有的值）

## 扩展练习3：完善异常中断

编程完善在触发一条非法指令异常 mret和，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。（

**答：**见git仓库
